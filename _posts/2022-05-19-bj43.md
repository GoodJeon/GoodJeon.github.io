---
layout: posts
comments: true
title: "[BOJ/백준-Python]4673번 - 셀프 넘버"
categories: Algorithm
tag: [BAEKJOON, 백준, algorithm, 알고리즘, python, 파이썬]


toc: true
toc_icon: "cog"
toc_sticky: true
date: 2022-05-19
last_modified_at: 2022-05-19

---



# 4673번 - 셀프 넘버



## 문제

셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.

양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 

예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.

33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...

n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 

생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97

10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.



## 입력

입력은 없다.



## 출력

10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.



## 예제 입력 1 

```

```



## 예제 출력 1

```
1
3
5
7
9
20
31
42
53
64
 |
 |       <-- a lot more numbers
 |
9903
9914
9925
9927
9938
9949
9960
9971
9982
9993
```



##  해결할 방법을 생각해보자.💡

셀프넘버가 아닌 것들을 구하고 그게 아니라면 셀프 넘버가 된다.

자연수를 생성자로 사용해서 `d(n)`을 만들어주고 거기에 값이 없다면 그것들이 셀프함수다.

예를들어 1은 생성자가 없고, 3도 생성자가 없다. 1+1은 2가 되고, 2+2는 4가 되기 때문이다.

그래서 우선은 자연수 `n`으로 `d(n)`을 만들어주는 함수를 만들어주자.

```python
def after_num(n):
    # 자연수 n을 받아서 문자열로 만들어주고 각 자리수를 원소로 가진 리스트 형태로 만들어 준다.
    num = list(str(n))
    # 위에서 리스트 형태로 만들어 줄 때 각 자리수의 값들은 string형태이므로 합을 해주기 위해 int형태로 바꿔줌
    num = lst(map(int, num))
    # d(n)을 만들 때 자연수 n 자신도 합해지므로 리스트에 추가해줌
    num.append(n)
    # 리스트 안의 요소들을 모두 더해줌
    result = sum(num)
    return result
```

이 함수를 사용하면  정수 n이 d(n)이 된다. 예를들어, `after_num(123)` 일 경우 `result`의 값은 `129`가 되어 돌아온다.

이제 만들어준 함수를 사용해서 0부터 자연수 10000까지 수를 생성자로 사용해보자. 람다를 사용해 0부터 10000까지의 수를 가진 리스트를 만들어준다.

```python
array_lst = [x for x in range(10001)]
```

그리고 함수 사용 후 값들이 저장될 리스트도 하나 만들어 준다.

```python
after_lst = []
```

이제 0부터 10000까지의 수를 사용해서 함수를 적용시켜 `d(n)`으로 만들고 빈 리스트(`after_lst`)에 추가해주자.

```python
for i in array_lst:
    after_lst.append(after_num(i))
```

반복문 실행 후 `after_lst`를 출력해보면 다음과 같이 나올 것이다.

```
[0, 2, 4, 6, 8, ... 10005, 10007, 10009, 10011, 10013, 10006, 10008, 10010, 10012, 10014, 10016, 10018, 10020, 10022, 10024, 10017, 10019, 10021, 10023, 10025, 10027, 10029, 10031, 10033, 10035, 10001]
```

이 중에서도 중복되는 값들이 있을 것이다. 따라서 집합(`set`)를 사용해서 중복값도 없애주고 정렬도 해준 후에 다시 리스트형태로 변환시켜주자.

```python
final_result = list(set(after_lst))
```

이제 마지막으로 1부터 10000까지의 수가 `final_result`에 들어가지 않는다면 출력해주게 만들면 10000까지의 셀프넘버들이 잘 출력된다!

```python
for i in range(1, 10001):
    if i in final_result:
        pass
   	else:
        print(i)
```







## 코드💻

```python
def after_num(n):
    num = list(str(n))
    num = list(map(int, num))
    num.append(n)
    result = sum(num)
    return result

array_lst = [x for x in range(10001)]
after_lst = []
for i in array_lst:
    after_lst.append(after_num(i))
final_result = list(set(after_lst))
for i in range(1, 10001):
    if i in final_result:
        pass
    else:
        print(i)
```





## 해결 로그 

| 문제 푼 날짜 | 체크 |
| :----------: | :--: |
|  2022-05-19  |  ✔   |
|              |      |
|              |      |
|              |      |
|              |      |



