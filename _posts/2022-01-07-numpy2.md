---
layout: posts
comments: true
title: "[NumPy]내가 보려고 올린 NumPy 정리2"
categories: Python
tag: [python, 파이썬, numpy, 넘파이, np, 패키지]
toc: true
toc_sticky: true
date: 2022-01-07
last_modified_at: 2022-01-07

---

**[Noitce]** 고쳐야하거나 틀린 것이 있으면 말씀해주세요!
{: .notice--info}



<br>



# NumPy 연산과 인덱싱

* 배열 연산
* 통계, 수학 정렬 연산
* 인덱싱과 슬라이싱

### nupy 모듈 선언


```python
import numpy as np
```


```python
np.__version__
```




    '1.19.2'



---

## 통계를 위한 연산

* 배열의 합, 평균, 표준편차, 분산, 최소값, 최대값, 누적합, 누적곱 등


```python
arr1 = np.arange(5)
arr1
```




    array([0, 1, 2, 3, 4])




```python
# 합과 (산술)평균 sum(), mean()
[arr1.sum(), arr1.mean()]
```




    [10, 2.0]




```python
# 표준편차와 분산 : std(), var()
[arr1.std(), arr1.var()]
```




    [1.4142135623730951, 2.0]




```python
# 최소값과 최대값 : min(), max()
[arr1.min(), arr1.max()]
```




    [0, 4]




```python
# 누적합과 누적곱 : cumsum(), cumprod()
arr2 = np.arange(1,5)
arr2
```




    array([1, 2, 3, 4])




```python
# 누적합 : cumsum()
arr2.cumsum()
```




    array([ 1,  3,  6, 10], dtype=int32)




```python
# 누적곱 : cumprod()
arr2.cumprod()
```




    array([ 1,  2,  6, 24], dtype=int32)



---

## 행렬 연산

* 선형 대수(Linear algebra)를 위한 행렬 (2차원 배열) 연산
* 행렬 곱, 전치 행렬, 역행렬, 행렬식 등
  * 행렬(matrix product) : A.dot(B) 혹은 np.dot(A,B)
  * 전치행렬(transpose matrix) : A.transpose() 혹은 np.transpose(A)
  * 역행렬(inverse matrix) : np.linalg.inv(A)
  * 행렬식(determinant) : np.linalg.det(A)



```python
A = np.arange(1, 5).reshape(2,2)
# 대체 방법1 : A = np.array([[1,2],[3,4]])
# 대체 방법2 : A = np.array([1,2,3,4]).reshape(2,2)
A
```




    array([[1, 2],
           [3, 4]])




```python
B = np.array([3,2,0,1]).reshape(2,2)
B
```




    array([[3, 2],
           [0, 1]])



### 행렬의 곱


```python
# 행렬의 곱
A.dot(B)
```




    array([[ 3,  4],
           [ 9, 10]])




```python
# 행렬의 곱 2
np.dot(A,B)
```




    array([[ 3,  4],
           [ 9, 10]])



### 전치 행렬


```python
# 전치 행렬 1
A.transpose()
```




    array([[1, 3],
           [2, 4]])




```python
# 전치 행렬 2
np.transpose(A)
```




    array([[1, 3],
           [2, 4]])



### 역행렬(np.linalg.inv(array))


```python
# 역행렬(inverse)
np.linalg.inv(A)
```




    array([[-2. ,  1. ],
           [ 1.5, -0.5]])




```python
# 행렬식(determinant)
np.linalg.det(A)
```




    -2.0000000000000004




```python
# A * inv(A) = I(단위행렬)
np.dot(A,np.linalg.inv(A)) # [[1,0],[0,1]]
```




    array([[1.00000000e+00, 1.11022302e-16],
           [0.00000000e+00, 1.00000000e+00]])



---

## Array 인덱싱(Indexing)과 슬라이싱(Slicing)

* 인덱싱(indexing) : 배열의 위치나 조건을 지정해 배열의 원소를 선택하는 것
* 슬라이싱(slicing) : 범위를 지정해 배열의 원소를 선택하는 것
  * : 연산자를 주로 사용

### 1차원 배열의 인덱싱

#### 배열명[위치]

* 파이썬의 인덱싱과 동일
* **`0번째`**로 시작함


```python
arr1 = np.arange(10)
arr1
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# 0번째 요소
arr1[0]
```




    0




```python
# 3번째 요소
arr1[3]
```




    3



#### 배열명[[위치1, 위치2, ... , 위치n]]


```python
# 1, 3, 4 위치 : 
# shape => (m, ) => 1차원, (m, n) => 2차원 (m, n, p) => 3차원
# 인덱스 [ ] : [ m] => [m,n] => [m, n, p]  (1,2,3차원)
# arr1[1,3,4] # => 3차원 배열의 위치 1면 3행 4열
# 여러 인덱스의 요소들을 지정 : 리스트로 주어야 한다.

arr1[[1,3,4]]
```




    array([1, 3, 4])



---

### 2차원 배열의 인덱싱

#### 배열명[행위치, 열위치]


```python
arr2 = np.arange(1, 13).reshape(3,4)
arr2
```




    array([[ 1,  2,  3,  4],
           [ 5,  6,  7,  8],
           [ 9, 10, 11, 12]])




```python
# 2차원의 array에서 인덱싱을 하기 위해선 2개의 인자를 입력해야 합니다.
arr2[2,3] # 2행 3열의 요소
```




    12




```python
# 0행 0열 값 변경
arr2[0,0] = 90
```


```python
# 변경된 array
arr2
```




    array([[90,  2,  3,  4],
           [ 5,  6,  7,  8],
           [ 9, 10, 11, 12]])



#### 2차원배열명[행위치]

: 2차원 배열에서 지정한 행 전체가 선택됨


```python
# 두번째 행 선택
arr2[1]
```




    array([5, 6, 7, 8])



#### 2차원배열명[:,열위치]

: 2차원 배열에서 지정한 열 전체가 선택됨


```python
arr2[:,1] # 두번째 열 선택
```




    array([ 2,  6, 10])



#### 2차원 배열의 특정 행을 지정해서 행 전체를 변경


```python
# 두번째 행 변경
arr2[1] = np.array([-5, 1, 10 ,9])
arr2
```




    array([[90,  2,  3,  4],
           [-5,  1, 10,  9],
           [ 9, 10, 11, 12]])



#### 배열명[[행위치1, 행위치2, ..., 행위치n], [열위치1, 열위치2, ..., 열위치n]]

: 지정한 (행위치1, 열위치1), (행위치2, 열위치2), ..., (행위치n, 열위치n)의 원소를 가져옴


```python
arr2[[0,2],[0,1]] # 0행 0열 2행 1열
```




    array([90, 10])



#### 배열명[조건]

: 배열에서 조건을 만족하는 원소만 선택

* 10 초과인 원소 선택


```python
# 비교 연산 10 초과인 원소 선택
arr2 > 10
```




    array([[ True, False, False, False],
           [False, False, False, False],
           [False, False,  True,  True]])




```python
arr2[arr2 > 10] # arr2에서 원소가 10 초과하는 원소들을 가져옴
```




    array([90, 11, 12])



* 짝수인 원소 선택


```python
# 짝수인 원소 선택
arr2[arr2 % 2 == 0]
```




    array([90,  2,  4, 10, 10, 12])



---

### 1차원 배열의 슬라이싱(Slicing)

#### 배열[시작위치:끝위치]

: 시작위치에서 끝위치-1 에 해당하는 배열의 원소를 반환


```python
arr1
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# 3번째 요소부터 8번째 요소
arr1[3:9]
```




    array([3, 4, 5, 6, 7, 8])



#### 배열명[start:end+1:step]

: start에서 end 범위까지의 자료 중 step 간격으로 인덱스를 지정


```python
arr1[3:9:2]
# arr[[3,5,7]]과 같음
```




    array([3, 5, 7])




```python
arr1[:9:2] # 처음부터 8까지 2씩
```




    array([0, 2, 4, 6, 8])




```python
arr1[3::2] # 3부터 끝까지 2씩
```




    array([3, 5, 7, 9])




```python
arr1[::3] # 처음부터 끝까지 3씩
```




    array([0, 3, 6, 9])




```python
arr1[::-1] # 마지막부터 처음까지 (reverse)
```




    array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])




```python
arr1[::-2] # 마지막부터 처음까지 2씩
```




    array([9, 7, 5, 3, 1])



#### 배열[:끝위치]

: 처음부터 '끝위치-1'원소 반환


```python
arr1[:3]
```




    array([0, 1, 2])



#### 배열[시작위치:]

: 시작부터 끝까지 원소 반환


```python
arr1[2:]
```




    array([2, 3, 4, 5, 6, 7, 8, 9])



#### 배열[:]

: 모든 원소 반환


```python
arr1[:]
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



---

### 2차원 배열의 슬라이싱

#### 배열[행시작위치:행끝위치, 열시작위치:열끝위치]


```python
arr2
```




    array([[90,  2,  3,  4],
           [-5,  1, 10,  9],
           [ 9, 10, 11, 12]])




```python
# 2행의 모든 요소 꺼내기
arr2[2,:]
```




    array([ 9, 10, 11, 12])




```python
# 2행의 모든 요소 꺼내기
arr2[2]
```




    array([ 9, 10, 11, 12])




```python
# 3열의 모든 요소 꺼내기
arr2[:,3]
```




    array([ 4,  9, 12])




```python
# 1~2행, 1~2열의 요소
arr2[1:3,1:3]
```




    array([[ 1, 10],
           [10, 11]])



#### 배열[행위치][열시작위치:열끝위치]

: 특정 행을 선택한 후 열을 슬라이싱


```python
arr3 = np.arange(10,100, 10).reshape(3,3)
arr3
```




    array([[10, 20, 30],
           [40, 50, 60],
           [70, 80, 90]])




```python
# 1행의 0열과 1열 요소 선택
arr3[1,:2]
```




    array([40, 50])




```python
# 1행의 0열과 1열 요소 선택
arr3[1][:2]
```




    array([40, 50])




```python
# 참고. 인덱싱 예
arr3[2][1]
```




    80



#### 슬라이싱 된 배열에 값을 지정


```python
# 0~1행, 1~2열의 요소 변경
arr3[:2, 1:] = np.array([2,3,5,6]).reshape(2,2)
arr3
```




    array([[10,  2,  3],
           [40,  5,  6],
           [70, 80, 90]])



---

## Array boolean 인덱싱(Mask)

* 다차원의 인덱싱을 응용하여 boolean 인덱싱
* boolean인덱승을 통해 만들어낸 array를 통해 원하는 행 또는 열의 값만 뽑아냄
* 가리고 싶은 부분은 가리고, 원하는 요소만 꺼냄


```python
names = np.array(['Beomwoo', 'Beomwoo', 'Kim', 'Joan', 'Lee', 'Beomwoo','Park', 'Beomwoo'])
names
```




    array(['Beomwoo', 'Beomwoo', 'Kim', 'Joan', 'Lee', 'Beomwoo', 'Park',
           'Beomwoo'], dtype='<U7')




```python
# names 크기 확인
names.shape
```




    (8,)




```python
# 8행 4열의 실수 난수 배열 생성
data = np.random.randn(8,4)
data
```




    array([[-0.46821544, -2.82127206,  1.17384042,  1.4126358 ],
           [-0.41468141, -1.32184734, -0.97718296, -0.08295454],
           [-1.17581805,  0.16010913,  0.4640075 ,  1.1831278 ],
           [-1.08755004, -1.17021442,  0.20366883, -0.36275755],
           [-0.59289806, -0.44724656, -0.43670415,  0.85200045],
           [ 1.79597087, -1.45440975,  2.84134888, -0.86147657],
           [ 0.67129261, -0.19201303,  1.45651852, -0.06437053],
           [-1.78837502, -0.30970071,  0.00801997, -1.16543785]])




```python
# 배열 크기 확인
data.shape # 8행 4열
```




    (8, 4)




```python
# 요소가 Beomwoo인 항목에 대한 mask 생성
names_mask_Beomwoo = (names == 'Beomwoo')
names_mask_Beomwoo
```




    array([ True,  True, False, False, False,  True, False,  True])




```python
# 요소가 Beomwoo인 항목의 위치와 같은 행의 자료 가져오기
data[names_mask_Beomwoo, :]
# data[names_mask_Beomwoo] : 같은 결과
```




    array([[-0.46821544, -2.82127206,  1.17384042,  1.4126358 ],
           [-0.41468141, -1.32184734, -0.97718296, -0.08295454],
           [ 1.79597087, -1.45440975,  2.84134888, -0.86147657],
           [-1.78837502, -0.30970071,  0.00801997, -1.16543785]])




```python
names_mask_Kim = (names == 'Kim')
names_mask_Kim
```




    array([False, False,  True, False, False, False, False, False])




```python
# 요소가 Kim인 행의 데이터만 꺼내기
data[names_mask_Kim, :]
```




    array([[-1.17581805,  0.16010913,  0.4640075 ,  1.1831278 ]])




```python
# 논리 연산을 응용하여, 요소가 Kim 또는 Park인 행의 데이터만 꺼내기
n_mask_KimOrPark = (names == 'Kim') | (names == 'Park')
n_mask_KimOrPark
```




    array([False, False,  True, False, False, False,  True, False])




```python
data[n_mask_KimOrPark]
```




    array([[-1.17581805,  0.16010913,  0.4640075 ,  1.1831278 ],
           [ 0.67129261, -0.19201303,  1.45651852, -0.06437053]])



**마스크 인덱싱 문제**  

* 문제1. data array에서 0번째 열이 0보다 작은 행 데이터 가져오기


```python
# 1단계 마스크를 만든다.
     
data[:,0] < 0
```




    array([ True,  True,  True,  True,  True, False, False,  True])




```python
# 2단계, 생성된 마스크를 이용하여 0번째 열의 값이 0보다 작은 행을 구한다.
data[data[:,0] < 0]
```




    array([[-0.46821544, -2.82127206,  1.17384042,  1.4126358 ],
           [-0.41468141, -1.32184734, -0.97718296, -0.08295454],
           [-1.17581805,  0.16010913,  0.4640075 ,  1.1831278 ],
           [-1.08755004, -1.17021442,  0.20366883, -0.36275755],
           [-0.59289806, -0.44724656, -0.43670415,  0.85200045],
           [-1.78837502, -0.30970071,  0.00801997, -1.16543785]])



* 문제2. data array에서 0번째 열이 0보다 작은 행의 2,3번째 열 데이터 가져오기


```python
# 1단계 마스크 생성
```


```python
# 2단계 생성된 마스크를 이용해 0번째 열의 값이 0보다 작은 행의 2,3번째 열 데이터 가져오기
data[data[:,0] < 0][2:4]
# data[data[:,0]<0, 2:4]
```




    array([[-1.17581805,  0.16010913,  0.4640075 ,  1.1831278 ],
           [-1.08755004, -1.17021442,  0.20366883, -0.36275755]])



---

## array에 적용되는 다양한 함수

### 하나의 array에 적용되는 함수

#### random.rand(d0,d1,.., dn) : 표준정규난수 생성

* [https://numpy.org/doc/stable/reference/random/legacy.html
  
  ](https://numpy.org/doc/stable/reference/random/legacy.html
  )


```python
# 5행 3열의 실수난수 배열 생성
data = np.random.randn(5,3)
data
```




    array([[ 0.0966655 ,  0.93313054,  0.52754416],
           [ 0.88391742,  0.49115935,  0.48757577],
           [ 0.35367219, -0.41852283,  0.23604843],
           [ 0.02823907, -1.67744635, -0.33286717],
           [-0.68474982, -0.25353313, -0.7640626 ]])



---

### 수학 관련 함수

* 제곱근, 절대값, 삼각함수, 지수로그함수, 반올림함수 등
* [https://numpy.org/doc/stable/reference/routines.math.html
  
  ](https://numpy.org/doc/stable/reference/routines.math.html
  )


```python
# 각 성분의 절대값 계산하기
np.abs(data)
```




    array([[0.0966655 , 0.93313054, 0.52754416],
           [0.88391742, 0.49115935, 0.48757577],
           [0.35367219, 0.41852283, 0.23604843],
           [0.02823907, 1.67744635, 0.33286717],
           [0.68474982, 0.25353313, 0.7640626 ]])




```python
# 각 성분의 제곱근 계산하기 : data**0.5
np.sqrt(np.abs(data))
```




    array([[0.31091076, 0.96598682, 0.72632235],
           [0.94016883, 0.70082762, 0.69826626],
           [0.59470345, 0.6469334 , 0.48584815],
           [0.16804484, 1.29516267, 0.57694642],
           [0.82749612, 0.50352074, 0.87410674]])




```python
# 각 성분의 제곱 계산하기
np.square(data)
```




    array([[9.34421896e-03, 8.70732598e-01, 2.78302841e-01],
           [7.81310013e-01, 2.41237511e-01, 2.37730127e-01],
           [1.25084017e-01, 1.75161356e-01, 5.57188605e-02],
           [7.97444954e-04, 2.81382626e+00, 1.10800554e-01],
           [4.68882319e-01, 6.42790491e-02, 5.83791653e-01]])



#### 지수함수


```python
# 각 성분을 무리수 e의 지수로 삼은 값을 계산하기 e^x
np.exp(data)
```




    array([[1.10149186, 2.54245598, 1.69476512],
           [2.42036275, 1.63420975, 1.62836389],
           [1.42428821, 0.65801811, 1.26623563],
           [1.02864157, 0.18685052, 0.71686541],
           [0.50421636, 0.77605403, 0.46577034]])



#### 로그함수

* 자연로그 : log()
* 상용로그 : log10()
* 밑이2인 로그 : log2()


```python
# 자연로그
np.log(abs(data))
```




    array([[-2.33649871, -0.06921018, -0.6395227 ],
           [-0.12339163, -0.71098665, -0.71830958],
           [-1.03938482, -0.87102385, -1.44371829],
           [-3.56704887,  0.51727261, -1.10001175],
           [-0.37870173, -1.37226077, -0.26910556]])




```python
# 상용로그
np.log10(abs(data))
```




    array([[-1.0147285 , -0.0300576 , -0.27774118],
           [-0.05358831, -0.30877758, -0.31195789],
           [-0.45139909, -0.37828085, -0.62699889],
           [-1.54914964,  0.22464864, -0.47772904],
           [-0.16446807, -0.59596528, -0.11687106]])




```python
# 밑이 2인 로그
np.log2(abs(data))
```




    array([[-3.3708551 , -0.09984918, -0.92263623],
           [-0.1780165 , -1.02573692, -1.03630168],
           [-1.49951532, -1.25662178, -2.08284522],
           [-5.14616372,  0.74626663, -1.5869815 ],
           [-0.54635111, -1.9797538 , -0.38823726]])



#### 각 성분의 부호 계산 : sign()

: +인 경우1, -인 경우 -1, 0인 경우 0


```python
# 각 성분의 부호 계산하기(+인 경우 1, -인 경우 -1, 0인 경우 0)
np.sign(data)
```




    array([[ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 1., -1.,  1.],
           [ 1., -1., -1.],
           [-1., -1., -1.]])



#### 반올림 함수


```python
data
```




    array([[ 0.0966655 ,  0.93313054,  0.52754416],
           [ 0.88391742,  0.49115935,  0.48757577],
           [ 0.35367219, -0.41852283,  0.23604843],
           [ 0.02823907, -1.67744635, -0.33286717],
           [-0.68474982, -0.25353313, -0.7640626 ]])




```python
# 각 성분의 소수 첫 번째 자리에서 내림한 값을 계산하기
np.floor(data)
```




    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.],
           [ 0., -1.,  0.],
           [ 0., -2., -1.],
           [-1., -1., -1.]])



#### NaN 여부 확인(결측치 확인)


```python
# 각 성분이 NaN인 경우 True를, 아닌 경우 Fasle를 반환하기
np.isnan(data)
```




    array([[False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False]])




```python
# 로그변환한 배열 중 NaN 확인
np.isnan(np.log(data))
```

    <ipython-input-81-93220a73000a>:2: RuntimeWarning: invalid value encountered in log
      np.isnan(np.log(data))





    array([[False, False, False],
           [False, False, False],
           [False,  True, False],
           [False,  True,  True],
           [ True,  True,  True]])



#### 무한대(inf) 확인


```python
# 각 성분이 무한대인 경우 True를, 아닌 경우 False를 반환하기
np.isinf(data)
```




    array([[False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False],
           [False, False, False]])



#### 삼각함수

: 각 성분에 대해 삼각함수 값을 계산하기(cos, cosh, sin, sinh, tan, tanh)


```python
# cos()
np.cos(data)
```




    array([[ 0.99533153,  0.59532156,  0.86404598],
           [ 0.63412695,  0.88178664,  0.88347117],
           [ 0.9381072 ,  0.91369028,  0.97226969],
           [ 0.9996013 , -0.10644796,  0.94510937],
           [ 0.7745773 ,  0.96803227,  0.72203123]])




```python
# cosh()
np.cosh(data)
```




    array([[1.00467575, 1.46788823, 1.14240869],
           [1.41676198, 1.12306315, 1.12123862],
           [1.06319665, 1.08886656, 1.02798903],
           [1.00039875, 2.76936111, 1.0559137 ],
           [1.24374598, 1.03231205, 1.30637559]])



#### Sums, products, differences 함수


```python
data
```




    array([[ 0.0966655 ,  0.93313054,  0.52754416],
           [ 0.88391742,  0.49115935,  0.48757577],
           [ 0.35367219, -0.41852283,  0.23604843],
           [ 0.02823907, -1.67744635, -0.33286717],
           [-0.68474982, -0.25353313, -0.7640626 ]])




```python
# 전체 성분의 합을 계산
np.sum(data)
```




    -0.09322947469277532




```python
# 열 간의 합을 계산(axis가 1일때 열끼리 합해줌.)
np.sum(data, axis = 1)
```




    array([ 1.5573402 ,  1.86265254,  0.17119779, -1.98207445, -1.70234555])




```python
# 행 간의 합을 계산(axis가 0일때 행끼리 합해줌.)
np.sum(data, axis = 0)
```




    array([ 0.67774436, -0.92521242,  0.15423858])



#### 평균(mean), 표준편차(std), 분산(var)


```python
# 전체 성분의 평균 계산
np.mean(data)
```




    -0.0062152983128516874




```python
# 행별로 평균 계산 axis=1
np.mean(data, axis=1)
```




    array([ 0.5191134 ,  0.62088418,  0.05706593, -0.66069148, -0.56744852])




```python
# 열별로 평균 계산 axis=0
np.mean(data, axis=0)
```




    array([ 0.13554887, -0.18504248,  0.03084772])




```python
# 전체 성분의 표준편차 계산
np.std(data)
```




    0.6741127190375007




```python
# 열별로 표준편차 계산
np.std(data, axis=0)
```




    array([0.50863553, 0.89375983, 0.50231188])




```python
# 행별로 표춘편차 계산
np.std(data, axis=1)
```




    array([0.34153745, 0.18599834, 0.33970314, 0.73391292, 0.22432087])



#### 최대값(max), 최소값(min)


```python
# 각 열에서 최소값
np.min(data, axis=0)
```




    array([-0.68474982, -1.67744635, -0.7640626 ])




```python
# 각 행에서 최대값
np.max(data, axis=1)
```




    array([ 0.93313054,  0.88391742,  0.35367219,  0.02823907, -0.25353313])



#### 최대값, 최소값 위치 인덱스 : argmax(), argmin()


```python
data
```




    array([[ 0.0966655 ,  0.93313054,  0.52754416],
           [ 0.88391742,  0.49115935,  0.48757577],
           [ 0.35367219, -0.41852283,  0.23604843],
           [ 0.02823907, -1.67744635, -0.33286717],
           [-0.68474982, -0.25353313, -0.7640626 ]])




```python
# 전체 성분의 최소값, 최대값이 위치한 인덱스를 반환
# 최소값의 위치, 최대값의 위치
[np.argmin(data), np.argmax(data)]
# 일차원적인 배열의 위치로 알려준다.(행 우선 단위ㅠ)
```




    [10, 1]




```python
# 행방향으로 최대값이 위치한 인덱스 반환
np.argmax(data, axis=1)
```




    array([1, 0, 0, 0, 1], dtype=int64)



#### 누적합(cumsum), 누적곱(cumprod)


```python
# 맨 처음 성분부터 각 성분까지의 누적합 또는 누적곱을 계산(cumsum, cumprod)
np.cumsum(data)
```




    array([ 0.0966655 ,  1.02979604,  1.5573402 ,  2.44125762,  2.93241698,
            3.41999274,  3.77366493,  3.3551421 ,  3.59119053,  3.6194296 ,
            1.94198325,  1.60911608,  0.92436626,  0.67083312, -0.09322947])




```python
# 열기준 누적합
np.cumsum(data, axis=0)
# 각 열에서 0행부터 내려가면서 더해준다고 생각하면 된다.
```




    array([[ 0.0966655 ,  0.93313054,  0.52754416],
           [ 0.98058292,  1.42428989,  1.01511993],
           [ 1.33425511,  1.00576706,  1.25116835],
           [ 1.36249418, -0.67167929,  0.91830118],
           [ 0.67774436, -0.92521242,  0.15423858]])




```python
# 누적곱
np.cumprod(data)
```




    array([ 9.66655004e-02,  9.02015302e-02,  4.75852905e-02,  4.20614674e-02,
            2.06588832e-02,  1.00727708e-02,  3.56245888e-03, -1.49097036e-03,
           -3.51941210e-04, -9.93849171e-06,  1.66712866e-05, -5.54932402e-06,
            3.79989864e-06, -9.63400204e-07,  7.36098062e-07])




```python
np.cumprod(data, axis=1)
```




    array([[ 0.0966655 ,  0.09020153,  0.04758529],
           [ 0.88391742,  0.43414431,  0.21167824],
           [ 0.35367219, -0.14801988, -0.03493986],
           [ 0.02823907, -0.04736952,  0.01576776],
           [-0.68474982,  0.17360677, -0.13264644]])



#### 정렬 sort


```python
data
```




    array([[ 0.0966655 ,  0.93313054,  0.52754416],
           [ 0.88391742,  0.49115935,  0.48757577],
           [ 0.35367219, -0.41852283,  0.23604843],
           [ 0.02823907, -1.67744635, -0.33286717],
           [-0.68474982, -0.25353313, -0.7640626 ]])




```python
# 전체 성분에 대해서 오름차순으로 정렬
np.sort(data) # 행 별로 오름차순으로 정리된다.
```




    array([[ 0.0966655 ,  0.52754416,  0.93313054],
           [ 0.48757577,  0.49115935,  0.88391742],
           [-0.41852283,  0.23604843,  0.35367219],
           [-1.67744635, -0.33286717,  0.02823907],
           [-0.7640626 , -0.68474982, -0.25353313]])




```python
# 전체 성분에 대해서 [::-1]를 적용 : 정렬후 마지막행부터 표시
np.sort(data)[::-1] 
# data의 밑에서부터  행별로 내림차순을 따져서 내려간다.
```




    array([[-0.7640626 , -0.68474982, -0.25353313],
           [-1.67744635, -0.33286717,  0.02823907],
           [-0.41852283,  0.23604843,  0.35367219],
           [ 0.48757577,  0.49115935,  0.88391742],
           [ 0.0966655 ,  0.52754416,  0.93313054]])




```python
# 열 방향으로 오름차순으로 정렬(각 열마다 정렬)
np.sort(data, axis=0)
```




    array([[-0.68474982, -1.67744635, -0.7640626 ],
           [ 0.02823907, -0.41852283, -0.33286717],
           [ 0.0966655 , -0.25353313,  0.23604843],
           [ 0.35367219,  0.49115935,  0.48757577],
           [ 0.88391742,  0.93313054,  0.52754416]])




```python
# 행 방향으로 오름차순으로 정렬(각 행마다 정렬)
np.sort(data, axis=1)
```




    array([[ 0.0966655 ,  0.52754416,  0.93313054],
           [ 0.48757577,  0.49115935,  0.88391742],
           [-0.41852283,  0.23604843,  0.35367219],
           [-1.67744635, -0.33286717,  0.02823907],
           [-0.7640626 , -0.68474982, -0.25353313]])



---

### 두 개의 array에 적용되는 함수


```python
data1 = np.random.randn(5,3) # 5행 3열의 실수난수 생성
data1
```




    array([[-1.04784123,  0.62312167,  0.14327893],
           [ 0.56360901,  1.08324609,  0.38043529],
           [-1.57016362, -0.96219305, -0.88502023],
           [-1.14501879, -0.84063558,  1.53340534],
           [-0.44242834, -1.54254728, -2.64162847]])




```python
data2 = np.random.randn(5,3) # 5행 3열의 실수난수 생성
data2
```




    array([[ 0.95913539, -1.58548375, -1.14909123],
           [ 0.35921551, -1.89877362,  0.63334318],
           [-1.51366682,  0.29963955, -0.71256125],
           [-1.02113484,  0.41621584, -0.66237842],
           [ 0.28402433,  0.70448944, -0.92991448]])



#### 두개의 array에 대해 동일한 위치의 성분끼리 연산

* add(), subtract(), multiply(), divide()


```python
# 두 배열의 합
np.add(data1, data2)
```




    array([[-0.08870584, -0.96236209, -1.0058123 ],
           [ 0.92282452, -0.81552753,  1.01377847],
           [-3.08383044, -0.6625535 , -1.59758148],
           [-2.16615363, -0.42441974,  0.87102693],
           [-0.15840401, -0.83805784, -3.57154295]])




```python
# 두 배열의 차
np.subtract(data1, data2)
```




    array([[-2.00697662,  2.20860542,  1.29237016],
           [ 0.2043935 ,  2.98201971, -0.25290789],
           [-0.0564968 , -1.2618326 , -0.17245898],
           [-0.12388395, -1.25685142,  2.19578376],
           [-0.72645267, -2.24703672, -1.71171399]])




```python
# 두 배열의 곱
np.multiply(data1, data2)
```




    array([[-1.00502161, -0.98794928, -0.16464056],
           [ 0.2024571 , -2.0568391 ,  0.2409461 ],
           [ 2.37670458, -0.28831109,  0.63063112],
           [ 1.16921858, -0.34988585, -1.0156946 ],
           [-0.12566041, -1.08670827,  2.45648857]])




```python
# 두 배열의 나누기
np.divide(data1, data2)
```




    array([[-1.09248521, -0.39301675, -0.12468891],
           [ 1.56899966, -0.57049776,  0.60067796],
           [ 1.03732446, -3.21116842,  1.24202689],
           [ 1.12131987, -2.0197107 , -2.31499896],
           [-1.5577128 , -2.18959602,  2.84072195]])



#### 최대값 또는 최소값 계산 : maximum(), minimum()


```python
np.maximum(data1, data2)
# 둘을 비교해서 큰 값을 원소에 넣어준다.
```




    array([[ 0.95913539,  0.62312167,  0.14327893],
           [ 0.56360901,  1.08324609,  0.63334318],
           [-1.51366682,  0.29963955, -0.71256125],
           [-1.02113484,  0.41621584,  1.53340534],
           [ 0.28402433,  0.70448944, -0.92991448]])




```python
np.minimum(data1, data2)
# 둘을 비교해서 작은 값을 원소에 넣어준다.
```




    array([[-1.04784123, -1.58548375, -1.14909123],
           [ 0.35921551, -1.89877362,  0.38043529],
           [-1.57016362, -0.96219305, -0.88502023],
           [-1.14501879, -0.84063558, -0.66237842],
           [-0.44242834, -1.54254728, -2.64162847]])

