---
layout: posts
comments: true
title: "[BOJ/백준-Python]2231번 - 분해합"
categories: Algorithm
tag: [BAEKJOON, 백준, algorithm, 알고리즘, python, 파이썬]


toc: true
toc_icon: "cog"
toc_sticky: true
date: 2022-06-21
last_modified_at: 2022-06-21
---



# 2231번 - 분해합



## 문제

어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.



## 입력

첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.



## 출력

첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.



## 예제 입력 1 

```
216
```



## 예제 출력 1

```
198
```





##  해결할 방법을 생각해보자.💡

생성자 중에서 가장 작은 생성자를 출력하는 문제다.

자연수 분해합 `N`을 받아주자.

```python
N = int(input())
```

생성자들을 담을 리스트 하나를 만들어주자.

```python
lst = []
```

자연수 1부터 (N-1)까지 모든 경우를 따져서 생성자를 구분해볼 것이다. 

```python
for i in range(1, N):
```

문제에 나와있듯, 생성자는 자기 자신과 각 자리수들을 더해서 분해합을 만들어낸다.

만약 생성자가 `123`이라면, `123 + 1 + 2 + 3` 으로 `129`가 분해합이된다.

그럼 어떻게 하면 좋을까?

변수 하나를 만들어서 자연수를 저장해 놓고, 문자열로 바꾼뒤에 각 문자열들을 정수로 변환해 변수에 더해준 뒤에 `N`이랑 비교하면된다.

```python
	sum = i
    for j in str(i):
        sum += int(j)
    if sum == N:
        lst.append(i)
```

이러면 `lst`라는 리스트에 생성자들이 들어가있을 것이다.

만약, 이 길이가 0이라면 생성자가 없는 것이므로 0을 출력하게 만들고,

존재한다면 가장 작은 값을 출력시키면 문제 해결이다!

```python
if len(lst) == 0:
    print(0)
else:
    print(min(lst))
```



그리고 사실 이 방법은 **채점에 오랜 시간이 걸렸다.**

난 최대한 내가 풀고자하는 마음 때문에 시간 고려를 안했는데, 다른 더 좋은 방법들이 있을 것이므로 찾아보는 것도 좋을 것 같다!



## 코드💻

```python
N = int(input())
lst = []
for i in range(1, N):
    sum = i
    for j in str(i):
        sum += int(j)
    if sum == N:
        lst.append(i)

if len(lst) == 0:
    print(0)
else:
    print(min(lst))
```





## 해결 로그 

| 문제 푼 날짜 | 체크 |
| :----------: | :--: |
|  2022-06-21  |  ✔   |
|              |      |
|              |      |
|              |      |
|              |      |



