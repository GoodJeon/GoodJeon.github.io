---
layout: posts
comments: true
title: "[web]JavaScript 정리4"
categories: Web
tag: [Web, 웹, 자바스크립트, JS, javascript]
toc: true
toc_sticky: true
date: 2022-01-26
last_modified_at: 2022-01-26
---

**[Noitce]** 고쳐야하거나 틀린 것이 있으면 말씀해주세요!
{: .notice--info}





<br>

# JavaScript 정리 4️⃣



## DOM 사용 연습

* 오늘은 이전에 알게 되었던 Document Object Model에 대해 공부했다. 
* 다양한 예제를 통해서 복습해본다.
* 이미지를 사용해야하는 예제는 제외하고 작성했다.





<br>



### 엘리먼트 생성

* 자바스크립트의 태그를 이용해 엘리먼트 객체를 생성할 수 있다.
* HTML 문서를 작성할 때, 직접 작성하는 경우 말고도 다른 문서를 불러와 그 정보들을 내가 원하는 형태로 페이지에 나타낼 수 있어야 한다. 그럴 때 사용하는 기능이다.
* 엘리먼트 객체를 생성, 객체에 속성을 부여, 텍스트 개체 생성 하는 document의 메소드를 사용해서 어떤 원리로 돌아가는지 이해해봤다.
* 엘리멘트 생성 과정
  * 엘리먼트 객체 생성 : `var 변수 = document.createElement('태그이름');`
    * 태그 이름에는 우리가 아는 `<div>`, `<p>` 등이 들어간다.
  * 객체에 속성 부여 
    * 방법1
      * `var 변수 = document.createAttribute('속성이름')` : 변수에 속성 객체를 만든다.
      * `속성객체.nodeValue = '적용할 속성들'` : 객체가 적용된 변수에 nodeValue에 적용하고 싶은 속성을 저장해준다.
      *  `엘리먼트객체.setAttributeNode(속성 객체)` : 속성을 엘리먼트 객체에 적용해준다.
    * 방법2
      * `setAttribute('속성이름', '속성값')` : 이 메소드는 방법1처럼 속성객체를 만들고 따로 속성값을 정해줄 필요 없이 한번에 그 둘을 해결할 수 있다.
  * 텍스트노드 생성
    * `var 변수 = document.createTextNode('텍스트내용')` : 입력한 텍스트내용을 담고 있는 텍스트 노드를 생성한다.
* 엘리먼트 생성하는 과정을 직접 확인해보자.
  * {% include codepen.html hash="JjOjbXE" title="hello" %}
  * HTML의 바디 태그
    * 엘리먼트를 생성과정을 확인하기 위해 버튼을 만들었고 클릭 이벤트가 생길 경우 `elementCreate()`란 함수가 실행되도록 코드를 적어줬다.
  * JS의 스크립트 태그
    * 엘리먼트를 생성하는 함수 `elementCreate()`를 정의한다.
    * 엘리먼트 객체를 생성하자. 영역을 지정하는 `<div>`태그를 사용할 것이다.
    * `div`라는 변수에 엘리먼트 객체 생성 메소드를 저장해준다. 태그이름은 `'div'`
    * 객체에 속성을 부여하는 방법2를 사용했다. css의 `style`기능을 속성을 사용할 것이며, 속성값은 2px 크기의 빨간색 일반적인 라인 테두리를 `div` 엘리먼트 객체에 적용해준다.
    * `txt`라는 변수에 '엘리먼트 생성' 이라는 문자열이 담긴 텍스트 노드를 생성해준다.
    * 자식노드를 추가하는 `appendChild()` 메소드를 사용해 `div`엘리먼트 객체의 하위에 텍스트 노드를 입혀준다.
    * 마지막으로 `<body>` 부분 가장 아래 위치에 `div`엘리먼트를 추가해준다.
* 이 버튼을 누르면 버튼을 만든 부분 밑으로 정의한 `div` 엘리먼트가 계속 생성되는 것을 확인할 수 있다.



​	 



<br>

### 부모/자식 노드를 사용한 기능 구현

* `.appendChild(노드)` : 부모 노드 하위 노드 끝에 자식노드를 추가(Append)하는 메소드 

* `.insertBefore(생성할노드, 기준위치노드)` : 선택자를 통해 해당 선택자보다 앞에 위치하게 노드를 생성하는 메소드

* 이 두 가지 메소드는 DOM의 핵심 메소드다.

* 예제를 통해서 복습해보자.

  {% include codepen.html hash="YzEzVKx" title="hello" %}

* HTML의 바디 태그 내부

  * `<h1>`태그로 '태그 추가하기'라는 제목을 만들어줬다.
  * 버튼 3개를 만들어 줬다.
  * `addAppend()` 버튼은 클릭했을 때 엘리먼트를 자식 노드중 가장 마지막 위치에 생성하는 함수를 발동
  * `addInsert()` 버튼은 클릭했을 때 지정한 노드의 위치보다 앞에 위치하게 노드를 생성하는 함수를 발동
  * `moveElement()` 버튼은 클릭했을 때 다른 버튼을 눌러 특정 위치에 생성된 엘리먼트들이  순서대로 바디태그 하위의 마지막으로 옮기게 하는 함수를 발동
  * `filedset`의 `id`를 `addElement`로 지정했고 그 안에는 `legend`와 `div` 태그를 만들어줬다.

* CSS style

  * 엘리먼트 생성할 때 `<p>`태그 엘리먼트를 생성할 것이므로
  * p 태그에 1px 굵기의 빨간색 일반 라인 테두리를 설정해줬다.

* JS의 스크립트 태그

  * 우선 HTML에서 함수 별로 버튼 3개를 만들어 줬기 때문에 함수도 3개를 만들어줘야 한다.
  * `addAppend()` 함수를 정의해준다.
    * `id=addElement`인 `fieldset`의 요소를 불러와 fieldset 이란 변수에 객체로 저장해준다.
    * 변수 p에는 p태그 엘리먼트 객체를 생성해 저장해준다.
    * 생성된 객체 p에 `.textContent`를 사용해 텍스트 내용을 넣어준다.
    * `fieldset`의 하위노드에서 마지막 위치에 `p`객체를 이용해 노드를 생성해준다.
  * `addInsert()` 함수에 사용할 전역변수 count를 1로 만들어준다.
  * `addInsert()` 함수를 정의해준다.
    * `newP`는 `<p>`태그 이용해 생성한 엘리먼트 객체
    * `fieldset`은 위 함수와 똑같다.
    * `newP`에 `.textContent`를 사용해 텍스트를 넣어주고, 생성 순서를 확인하기 위해 내용에 `(count++)`도 추가해준다.
    * `oldDiv`는 `fieldset` 의 자식 `div`의 선택자다.
    * `insertBefore`를 사용해  `oldDiv`보다 `newP` 엘리먼트 요소가 앞에 생성될 수 있도록 한다.
  * `moveElement()` 함수를 정의해준다.
    * `moveEle`는 `<fieldset>` 태그의 `<legened>`의 다음 위치에 자리한 요소의 선택자
    * `addEle` 는 `<body>` 태그다.
    * 바디태그 하위로 moveEle로 선택된 요소들을 마지막에 위치시켜준다.



**참고: childNodes와 children의 차이점은?**  

1. childNodes는 요소가 아닌 비 요소 노드도 포함해준다.
2. children은 요소 노드만 배열 형태로 반환해준다.







<br>

### 연락처를 입력 받아 테이블에 저장











<br>

## Ajax

* Asynchronous Javascript And Xml
* 비동기식 자바스크립트와 xml 
* 자바스크립트를 이용해 서버와 브라우저가 **비동기 방식**으로 데이터를 교환하는 통신 기능이다.
* XMLHttpRequest (XHR) : http를 통한 데이터 송수신 지원 객체
* 브라우저가 가지고 있는 XHR 객체를 이용해 전체 페이지를 새로 고치지 않고 페이지의 일부만을 위한 데이터를 로드하는 기법이다.

### 비동기 방식

* 웹페이지를 전체적으로 다시 로딩하지 않고 일부분만 갱신할 수 있다.
* **동기 방식**은 페이지 리로드를 통해 이미지, 스크립트 등의 리소스를 다시 불러와야 한다. 그래서 이것들이 바뀔 때마다 재요청 하면 불필요한 낭비가 생긴다. 
* **비동기 방식**은 필요한 부분만 부르며 전체 페이지의 리로드를 기다려지 않고 할일을 한다.
* 웹 페이지가 로드가 다 된 후에도 서버에게 데이터를 요청하고 받을 수 있다.



### readyState (요청 상태)

* 0 : uninitialized
* 1 : loading
* 2 : loaded
* 3 : interactive
* 4 : complete



### status (요청 완료 후 상태)

* 다양한 status가 존재하며, 대표적인 경우는 다음과 같다.

* 200 : success
* 400 : bad request
* 401 : unauthorized
* 403 : forbidden
* 404 : not found(자주 볼수 있쥬?)
* 415 : unsupported media type
* 500 : internal server error
* 보통 4xx은 클라이언트 문제, 5xx은 서버문제라고 생각하면 된다.

