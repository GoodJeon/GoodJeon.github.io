---
layout: posts
comments: true
title: "[Python기초]string 연습"
categories: Python
tag: [python, 파이썬, string, 문자열]
toc: true
toc_sticky: true
date: 2021-12-28
last_modified_at: 2021-12-28
---

**[Noitce]** 고쳐야하거나 틀린 것이 있으면 말씀해주세요!
{: .notice--info}

<br>

# 파이썬 string 연습문제




<br>

## 문제1: **이메일 주소를 입력받아 이메일 형식인지 아닌지를 판별하여 출력하자!**



<br>

 이메일은 숫자, 영어알파벳, @, .로 이루어져있다. 하지만 이메일 형식은 'ID @ 문자 . 문자 ' 이런식으로 이루어져있기에 @나 .의 위치가 바뀌어 형식을 벗어나면 제대로된 이메일을 받을 수 없다. 그래서 IsString과 문자열 인덱싱 등의 방법을 통해 이 문제를 해결해야한다.

<br>

- 출력 예시:

![py9-1](https://user-images.githubusercontent.com/75322297/147525846-6be80e7f-4c96-4d91-879c-03539d57621f.PNG)
{: .align-center}

- 이메일 형식이 아닌 경우가 적혀져 있는데, 저것들에 내 나름대로 조건을 더 추가해야한다고 생각해 정리해보았다.
  1. 이메일 형식이 아닌경우는
  2. @ 없는경우 
  3. . 없는경우   
  4. @이 .의 오른쪽에 위치한 경우 
  5. @과 .의 사이에 문자가 없는 경우 
  6. @앞에 문자가 없는 경우 
  7. .뒤에 문자가 없는 경우 
  8. @가 두 번 이상 있는 경우 
  9. .가 두 번 이상 있는 경우 
  10. 공백이 있는 경우 
  11. .뒤에 숫자나 특수문자가 있는 경우
  12. @과 . 사이에 숫자나 특수문자가 있는 경우
  13. @과. 외에 잡다한 특수문자가 들어갔을 경우   


이 정도로 정리해 볼 수 있다.  
그렇다면, 그 반대의 경우에 제대로된 이메일을 받을 수 있다는 건데 그 조건은 이렇다.

- 제대로된 이메일 형식
  1. '@'가 1개만 존재해야한다.
  2. '.'가 1개만 존재해야한다.
  3. 기타 특수문자가 없어야한다.
  4. 공백이 없어야한다.
  5. '.'이 무조건 '@' 오른쪽에 위치해야한다.
  6. '@'가 가장 왼쪽에 위치하면 안된다.
  7. '.'이 맨 뒤에 위치하면 안된다.
  8. '.' 뒤에 위치한 것이 문자여야 한다.(숫자는x)
  9. '@'과 '.' 사이에는 문자가 와야한다.(숫자는x)

위의 조건을 생각해서 이제 문제를 풀어보자.


<br>


```python
inp = input('이메일 입력 : ')
# inp에 이메일 형식의 문자열을 입력받는다.
```


```python
letter, digit, space, alpha, dot, etc = 0, 0, 0, 0, 0, 0
# 순서대로 문자, 숫자, 공백, @, ., 그 외 특수기호
# for문을 사용해서 각 문자의 개수를 카운트하기위해 0으로 지정해주는 변수들이다.
```
```python
for i in inp:
    if i.isalpha():
        letter += 1
    elif i.isdigit():
        digit += 1
    elif i.isspace():
        space += 1
    elif i == '@':
        alpha += 1
    elif i == '.':
        dot += 1
    else:
        etc += 1

# 입력받은 문자열 inp 값을 for문을 이용해 리터럴의 개수를 카운트 해준다. 
# .isalpha() 메소드는 문자를 판단
# .isdigit() 메소드는 숫자를 판단
# .isspace() 메소드는 공백을 판단
# @와 .은 연산자를 통해 확인
# 그 외의 특수기호 등은 etc로 분류해준다.

```

```python
if alpha == 1 and dot == 1 and etc == 0 and space == 0 and inp.find('@') < inp.find('.') \
        and inp[0] != '@' and inp[-1] != '.' and inp[inp.find('.') + 1].isalpha() \
        and inp[inp.find('@') + 1].isalpha():
    print('올바른 이메일입니다.')
else:
    print('이메일 형식이 아닙니다.')
print(f'입력한 이메일 : {inp}')

# 이제 여기서 이메일 형식이 되기 위한 조건을 하나씩 if 조건문에 적어준다.
# alpha == 1 => '@'가 1개만 존재해야한다.
# dot == 1 => '.'가 1개만 존재해야한다.
# etc == 0  => 기타 특수문자가 없어야한다.
# space == 0 => 공백이 없어야한다.
# inp.find('@') < inp.find('.') => '.'이 무조건 '@' 오른쪽에 위치해야한다.
# inp[0] != '@' => '@'가 가장 왼쪽에 위치하면 안된다.
# inp[-1] != '.' => '.'이 맨 뒤에 위치하면 안된다.
# inp[inp.find('.') + 1].isalpha() => '.' 뒤에 위치한 것이 문자여야 한다.(숫자는x)
# inp[inp.find('@') + 1].isalpha() => '@'과 '.' 사이에는 문자가 와야한다.(숫자는x) 

```

 실행시켜보면 우리가 사용하는 일반적인 이메일 형식을 적어준다면 올바른 이메일이 나왔다는 출력문과 입력한 문자열이 함께 나온다.

```
이메일 입력 : 513ehdwnsl@gmail.com
올바른 이메일입니다.
입력한 이메일 : 513ehdwnsl@gmail.com
```
다만, 아쉬운 점은 이메일 중에서도 14016049@suwon.ac.kr과 같이 .이 두개이상 들어가는 이메일도 존재한다는 점이다. 하지만 문제가 바라는 조건을 맞췄으니 만족한다.

<br>
<br>
<br>
<br>
<br>
<br>


## 문제2: **패턴이 있는 문자열에서 숫자만 추출해서 총 합계를 구해보자!**

<br>

스트링 함수 예제의 꽃이라고 보여진다. 하나의 패턴을 파악하고 거기서 필요한 것들만 추출하는 능력은 데이터를 다루는 직무에서는 상당히 기본적인 능력이라고 생각한다. 세상의 데이터 속에는 다양한 패턴이 존재할 것이고 그것을 파악해 데이터를 추출, 가공 하는 점은 상당히 중요하다.  문제 해결을 위해 split()과 리스트 슬라이싱이 필요하다고 생각한다. 이제 같이 한번 풀어보자. 
<br>

- 조건:

![py9-2](https://user-images.githubusercontent.com/75322297/147525849-e2e0d632-5007-4c37-bdf9-7ed8f7ac8776.PNG){: .align-center}
  

```python
str_data = "{a1:20},{a2:30},{a3:15},{a4:50},{a5:-14},{a6:15},{a7:20},{a8:70},{a9:-100}"

# 조건처럼 str_data에 일정 패턴의 문자열을 받아준다.
```

```python
a = str_data.split(',')
# .split()은 문자열을 인자를 중심으로 나누어 리스트로 반환해준다. 해당 코드는 , 를 기준으로 문자열을 나누어 a에 리스트의 요소들로 반환해준다고 생각하면 된다.
```
```python
print(a)
# 스플릿이 잘 되었는지 a를 확인해준다.
# ['{a1:20}', '{a2:30}', '{a3:15}', '{a4:50}', '{a5:-14}', '{a6:15}', '{a7:20}', '{a8:70}', '{a9:-100}']
```

```python
b = []
sum = 0
for i in a:
    b.append(i[4:]) #앞에 같은패턴 날리기
print(b) # 리스트 확인. 이제 뒤에 하나씩을 날려야한다.

# print(a)로 어느정도 똑같은 패턴이 있다는 것을 확인할 수 있는데, {oo:oo} 이 패턴에서 :의 앞은 온전한 숫자가 아니다.
# 이제 리스트 슬라이싱을 이용해 앞의 같은 패턴들을 날려줄 것이다.
# 슬라이싱 후의 리스트를 받을 리스트 b를 만들어 주고,
# 문제에서 요구하는 추출한 숫자들을 합하기 위한 sum 을 0으로 지정해준다.
# split한 문자열이 들어있는 리스트 a를 for 반복문을 사용해 날려주고 리스트 b에 저장해준다.
# 그리고 슬라이싱이 잘 되어있는지 b를 확인해주자.
```

```python
c = []
for i in b:
    c.append(int(i[:-1])) # 뒤에 }을 제거
print(c)

# b를 확인한 결과 숫자의 뒤에 }만 남았을 것이다. 이것 또한 슬라이싱으로 제거해버리고 새로운 리스트 c에 저장해준다.
# 그다음에 c 리스트를 확인해보자.
```

```python
for i in c:
    sum += i
print(f'총합은 {sum}입니다.')

# 잘 정리되어있는 리스트의 요소들을 for문으로 더해준다.
```
간단한 문제인 것 같지만 처음에는 상당한 시간을 생각했다.
나중에 매우 쓸일이 많을 것 같은 기술이다.
자, 이제 출력해보자. 결과가 나올 것이다.

```
총합은 106입니다.
```
<br>
<br>
<br>
<br>
<br>
<br>


## 문제3: **입력한 숫자만큼 하트를 출력해보자.**

<br>
입력문에서 정수를 받아 각 자리수의 숫자만큼 하트를 출력하는 문제다. 조건대로 for문과 문자열을 사용하면 되고, \u2665를 적으면 하트문자 하나가 출력된다.
파이썬을 이용해 출력해보자.
<br>

- 출력 예시:  
![py9-3](https://user-images.githubusercontent.com/75322297/147525852-f606f22d-97ae-4455-b5c1-9049d38912ce.PNG)
{: .align-center}

<br>


```python
print('\u2665')
# print문을 이용해 하트가 잘 나오는지부터 확인해보자.
```

```python
num = input('숫자 여러개를 입력하세요.')

# num에 숫자 여러개를 입력받아준다.
```

```python
lnum = len(num)
# lnum은 입력받은 num 문자열의 길이로 숫자의 자리수 만큼 여러줄의 출력문을 보여주기 위해 사용할 것이다.
```

```python
a = []
for i in range(lnum):
    a.append(num[i])

# 이제 문자열의 길이만큼 반복문을 실행해서 a의 리스트에 num에 입력했던 각 자리 수의 정수를 추가해준다.
```

```python
for h in a:
    print(heart.lstrip() * int(h))

# 마지막으로 for문을 이용해 a리스트에 있는 숫자만큼 하트를 출력해준다.
# 주의할 점!! : .lstrip() 메소드를 사용해 출력 예시와 같이 출력할 때마다 왼쪽에 공백이 없게 만들어 줘야 한다.
```

완료했다면, 출력해보자!

```
숫자 여러개를 입력하세요.1234
♥
♥♥
♥♥♥
♥♥♥♥
```